<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[全局序列比对]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%85%A8%E5%B1%80%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[Needleman–Wunsch algorithm序列比对是生物信息中常见的问题，算法有全局比对 Needleman-Wunsch和Smith-Waterman局部比对算法，两者非常相似，区别只是打分矩阵的差异。这里只以简单的双序列全局比对作为引子，具体描述可以参考维基百科（https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm）。算法用Python实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import numpy as npdef Needleman_Wunsch(seq1, seq2): a = len(seq1) b = len(seq2) if a == 0 or b == 0: return matrix = np.zeros((a+1, b+1)) matrix[0, :] = [-1*x for x in range(b+1)] matrix[:, 0] = [-1*x for x in range(a+1)] for i in range(1, a+1): for j in range(1, b+1): if seq1[i-1] == seq2[j-1]: top_left = matrix[i-1, j-1] + 1 else: top_left = matrix[i-1, j-1] + -1 up = matrix[i-1, j] + -1 right = matrix[i, j-1] + -1 score = max(top_left, up, right) matrix[i, j] = score newseq1 = &apos;&apos; newseq2 = &apos;&apos; while 1: if a == 0 or b == 0: break up = matrix[a-1, b] right = matrix[a, b-1] top_left = matrix[a-1, b-1] if top_left &gt;= right and top_left &gt;= up: newseq1 += seq1[a-1] newseq2 += seq2[b-1] a -= 1 b -= 1 elif up &gt; top_left and up &gt;= right: newseq2 += &apos;-&apos; newseq1 += seq1[a-1] a -= 1 elif right &gt; top_left and right &gt; up: newseq1 += &apos;-&apos; newseq2 += seq2[b-1] b -= 1 newseq1 = newseq1[::-1] newseq2 = newseq2[::-1] print newseq1 print &apos;&apos;.join([&apos;|&apos; if newseq1[i] == newseq2[i] else &apos; &apos; for i in range(len(newseq2))]) print newseq2]]></content>
  </entry>
  <entry>
    <title><![CDATA[consensus sequence]]></title>
    <url>%2F2019%2F03%2F07%2Fconsensus-sequence%2F</url>
    <content type="text"><![CDATA[怎么获得共有序列（consensus sequence）在网上大家会反复提到的一个问题是“我怎么从我的bam文件中获得共有序列（consensus)”，这个问题的翻版是“我怎么从我的bam文件中提取fasta序列”。当然，这个问题背后实际想表达的通常是获得样品中感兴趣区间的序列，然后进行多样本或多物种的序列比对。那些做过系统发育分析的人应该对这个问题很感兴趣？ 上面这些问题可以通过简单的两步来解决： 进行变异检测，获得VCF文件 VCF文件与参考基因组进行比较，替换变异的位点 变异检测的软件和方法多如牛毛，后面的公众号也会分享一些目前流行的工具和流程。这里假设你用bcftools 的mpileup进行变异的检测。 $ bcftools mpileup -Ou -f ref.fa input.bam | bcftools call -Oz -mv -o output.vcf.gz获得的VCF文件需要排序过的，并且是经过bgzip压缩和tabix 构建索引的步骤。排序可以下载vcftools，使用vcf-sort your.vcf.gz|bgzip &gt;sort.vcf.gz命令。 压缩参考命令如下： $ bgzip -c output.vcf &gt; output.vcf.gztabix 命令如下： $ tabix output.vcf.gz现在可以开始进行consensus序列的获取了，这里使用bcftools工具中的consensus命令。如果你想创建一个新的基于你的变异文件的参考基因组，参考下面这条命令： $ bcftools consensus -f ref.fa output.vcf.gz &gt; out.fa假如你只是对某个区间感兴趣的话，参考下面这条命令: $ samtools faidx ref.fa 8:11870-11890 | bcftools consensus output.vcf.gz -o out.fa当然多个区间也是可以的: $ samtools faidx -r regions.bed ref.fa | bcftools consensus output.vcf.gz -o out.fa还有不懂的可以后台回复。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Y-Haplo]]></title>
    <url>%2F2019%2F03%2F06%2FY-Haplo%2F</url>
    <content type="text"><![CDATA[YpredictYpredict is a python based software package that predicts y chromosome haplogroup. Here, I use calculate rank method to automatically find the most likely y haplogroup. For each y haplogroup, I give two mark (T or F) according their snp calling state. For Example, if the haplogroup O2a1a1a2a1 in isogg (https://isogg.org/tree/) haplogroup tree has six snps, five snps was observed. If the ratio is 5/6 &gt;= 0.2, I give the T mark. Else, F mark. For each haplogroup, I calculate the number of T mark as n_T, nonexist as n_F, along the routine from the ‘Y’ haplogroup to this haplogroup(rank = (n_T**2)/(n_T + n_F)). If the rank same, the max number of n_T of the haplogroup will be the most likely haplogroup. If rank and n_T are both the same, then ramdomly select the one of mathced haplogroup. The current version is 0.0.1 Dependence vcftools(http://vcftools.sourceforge.net/) biopython(https://biopython.org/wiki/Download) GATK(https://software.broadinstitute.org/gatk/download/) Getting Started Step1Download y haplogroup tree from isogg. Then, filter snp by snpfilter.py. In this step, hotspot and backmutate snp will be removed. Finally, two files map.json and ref_vcf.gz will be generated.python snpfilter.py -snp snp14.3.csv Step2In this step, we will use the file ref_vcf.gz generated by the step1 to make snp calling using gatk3.8 UnifiedGenotyper module. Critically, we use hg38 refrence genome in this step. java -Xmx32g -jar GenomeAnalysisTK.jar -T UnifiedGenotyper -R hg38.fa -I *.bam -o y.vcf.gz --intervals chrY -ploidy 1 --output_mode EMIT_ALL_SITES --genotyping_mode GENOTYPE_GIVEN_ALLELES --alleles ref_vcf.gz Step3Y chromosome haplogroup can be predicted by ypredict.py. In the this step, the scrip will automatically output the most likely haplogroup. The final result can be seen in ypredict.txt. More detail output write in ystatistics.csv. python ypredict.py -vcf y.vcf.gz -s hfspecial.xlsx -m map.json If you need to update y haplogroup tree file downloaded from isogg, you can redo step1 and get an updated map.json. Installgit clone https://github.com/N-damo/ypredict-master.git]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo]]></title>
    <url>%2F2019%2F03%2F06%2Fhexo%2F</url>
    <content type="text"><![CDATA[HEXOstep1hexo init mybloghexo new ‘firstblog’hexo ghexo d step2部署：修改站点配置文件：deploy: type: git repository: github@github.com:N-damo.github.io.git branch: master运行：npm install hexo-deployer-git –save运行：hexo g（本地生成静态文件）运行：hexo d（将本地静态文件推送至Github）打开浏览器，访问https://n-damo.github.io]]></content>
  </entry>
</search>
